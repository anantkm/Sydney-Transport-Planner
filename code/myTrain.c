
/* 
    the time complexity of the solution is O(n*(m^3)*(k^3)) 
    where n=number of stations 
          m=number of trains
          k=number of stops each train make. 
    
 O refers to big-oh.

 time consuming functions are 
 latestdepschedule which has complexity of O(m^2 * k^2) (which gets the latest dep schedule)   
 updatepriority which has complexity of O(m^3 * k^3)    (which updates the dist and goto station 1D array)


*/


/*
The flow of the program is 

1. Starts from Main function 
2. Once the user inputs number of stations, it creates memory for station name. Later we reference the stations using this mapping. 
3. While inputing stops of perticular line, it builds Linked list. This helps in calculating the distance between the stations (time). Also helps in finding TO, FROM, Strat Point and End Point of train line. 
4. Using Linked List, I build the Graph. (More details (rough pictorial rep )about the Graph is available in Graph.h )
5. Once Graph is ready, I apply algorithm inspired from Dijkestra on the Destination. I use Priority queue. Station with highest departure time is the priority.

Scope for improvement.
1. Could have stored time in struct instead of storing it as int. 
2. Using dynamic memory for Queue instead of static. With current implementation,we can have only max of 50000 stations.

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "list.h"
#include "queue.h"
#include "Graph.h"

//this function prints the schedule generated by the algorithem.
void printschedule(Graph g, int nS, int source, int dest, int pred[], int line[], char **stnheadforfn)
{

  int i = 0;
  int schedulearray[MAX_NODES];
  int stationarray[MAX_NODES];
  int orignalsource = source;
  bool flag = true;
  bool flag1 = true;
  for (i = 0; i < MAX_NODES; i++)
  {
    schedulearray[i] = -1;
    stationarray[i] = -1;
  }
  int nextstn = -1;
  for (i = 0; i < nS; i++)
  {
    if (flag1 == true)
    {

      if (pred[orignalsource] == -1)
      {
        printf("No connection found.\n");
        flag1 = false;
      }

      else if (flag)
      {
        if (source == dest)
          flag = false;
        nextstn = pred[source];
        schedulearray[i] = line[source];
        stationarray[i] = source;
        source = nextstn;
      }
    }
  }

  i = 0;
  while (schedulearray[i] != -1 && flag1 == true)
  {
    int currenttime = timeofgvngblsch(g, stationarray[i], schedulearray[i]);
    int nextgblsch = nextgblscfrmgvnsc(g, stationarray[i], schedulearray[i]);

    if (nextgblsch == schedulearray[i + 1])
    {
      printf("%04d ", currenttime);
      printf("%s\n", stnheadforfn[stationarray[i]]);
    }
    else if (nextgblsch != schedulearray[i + 1] && schedulearray[i + 1] != -1)
    {
      int arrivingstn = stationarray[i + 1];
      int arrivaltime = timeofgvngblsch(g, arrivingstn, nextgblsch);
      printf("%04d ", currenttime);
      printf("%s\n", stnheadforfn[stationarray[i]]);
      printf("%04d ", arrivaltime);
      printf("%s\n", stnheadforfn[arrivingstn]);
      printf("Change at %s\n", stnheadforfn[arrivingstn]);
    }
    else if (schedulearray[i + 1] == -1)
    {

      int arrivingstn = nextstnofgbl(g, stationarray[i], schedulearray[i]);
      int arrivaltime = timeofgvngblsch(g, arrivingstn, nextgblsch);
      printf("%04d ", currenttime);
      printf("%s\n", stnheadforfn[stationarray[i]]);
      printf("%04d ", arrivaltime);
      printf("%s\n", stnheadforfn[arrivingstn]);
    }
    i = i + 1;
  }
}

//function to update the priority (Time) for the Queue. 
void updatepriority(Graph g, int source, int dist[], int pred[], bool vSet[], int time[], int line[])
{
  int nL = numberoflines(g, source);
  for (int i = 0; i < nL; i++)
  { // i represents line of the source station.

    int frmstn = fromstnoflcl(g, source, i);

    if (frmstn != SRTSTN)
    {
      //int gblsch = globalschfromlcl(g, frmstn, i);
      int gblsch = globalschfromlcl(g, source, i);

      int currentime = timeofgvnlclsch(g, source, i);         //time of the station where this line is in.
      int distothis = distofgvngblsch(g, frmstn, gblsch);     //taking distance from the from station.
      int deptimefrmstn = timeofgvngblsch(g, frmstn, gblsch); //time from fromstn.
      if (frmstn != SRTSTN && frmstn != STPSTN && distothis != STPSTN && currentime <= time[source] && deptimefrmstn < time[source])
      {
        int ltstdepsch = gblsch;
        ltstdepsch = latestdepschedule(g, frmstn, source, gblsch, time[source]);
        if (ltstdepsch != gblsch)
        {
          distothis = distofgvngblsch(g, frmstn, ltstdepsch);     //taking distance from the from station.
          deptimefrmstn = timeofgvngblsch(g, frmstn, ltstdepsch); //time from fromstn.
        }
        if (vSet[frmstn] == true)
        {
          int currentdist = dist[source] + distothis;
          if (deptimefrmstn > time[frmstn])
          {
            dist[frmstn] = currentdist;
            pred[frmstn] = source;
            time[frmstn] = deptimefrmstn;
            line[frmstn] = ltstdepsch;
          }
          else if (deptimefrmstn == time[frmstn] && currentdist < dist[frmstn])
          {
            dist[frmstn] = currentdist;
            pred[frmstn] = source;
            time[frmstn] = deptimefrmstn;
            line[frmstn] = ltstdepsch;
          }
          joinPQueue(frmstn); //enqueuing the queue.
        }
      }
    }
  }
  vSet[source] = false; // updating the processed node.
}

// I'm applying dijkstraSSP on destination. In real problem, if I'm travelling from 0 - 5, 5 is my source. For priority queue I'm passing array which has time of the staiton
 void dijkstraSSSP(Graph g, int source, int destination, int timeval, char **stnheadforfn)
{
  int dist[MAX_NODES];
  int pred[MAX_NODES];
  bool vSet[MAX_NODES]; // vSet[v] = true <=> v has not been processed
  int time[MAX_NODES];
  int line[MAX_NODES];

  int s = 0;
  int i = 0;
  int orgsrc = source;
  PQueueInit();
  int nV = numOfStations(g);
  for (s = 0; s < nV; s++)
  {
    joinPQueue(s);
    dist[s] = VERY_HIGH_VALUE;
    pred[s] = -1;
    vSet[s] = true;
    time[s] = 0;
    line[s] = -1;
    joinPQueue(i);
  }
  dist[source] = 0;
  pred[source] = source; //setting predecessor of source to source itself.
  time[source] = timeval;

  while (!PQueueIsEmpty())
  {
    source = leavePQueue(time); //getting the element from the priority queue.
    updatepriority(g, source, dist, pred, vSet, time, line);
  }
  printschedule(g, nV, destination, orgsrc, pred, line, stnheadforfn);
}

// function to keep track of the Stations with the index value.
char **crstationarray(int n)
{
  int i = 0;                                  // variable to iterate the loop.
  char **head;                                // a pointer to an unknown number of arrays
  head = (char **)malloc(n * sizeof(char *)); // allocate the array pointers
  for (i = 0; i < n; i++)
  {
    head[i] = malloc(32); // allocate an array for the next name
  }
  return head;
}

//function that returns the station index.
int fndstnname(char **stnhead, char station[], int n)
{
  int stationindex = 0;
  int i = 0;
  for (i = 0; i < n; i++)
  {
    if (!strcmp(station, stnhead[i]))
    {
      stationindex = i;
    }
  }
  return stationindex;
}

int main(void)
{

  int numofstations = 0; // variable to keep track of the number of stations.
  char **stnhead;        // pointer to pointer that points to stations name.
  char findme[31];
  int numberoflines = 0;
  int numberofstops = 0;
  List ListHead = NULL;
  List TempHead = NULL;
  int i = 0;
  int input = 0;
  int timevar = 0;
  int si = 0;

  //these variables are used while inputting the from and to stations.(near and inside the while loop)
  char fromstation[31];
  char tostation[31];
  int inputarriveby;
  int mapFromStn = 0;
  int mapToStn = 0;

  printf("Enter the number of stations: ");
  scanf("%d", &numofstations);             //inputs the number of stations
  stnhead = crstationarray(numofstations); // allocates the space for number of stations in the melloc.
  for (i = 0; i < numofstations; i++)
  {
    scanf("%s", stnhead[i]); // inputs the name of the induvidual station.
  }
  char **stnheadforfn = stnhead; // making copy of station name's starting address to pass on to the functions.
  printf("Enter the number of trains: ");
  scanf("%d", &numberoflines); // variable for number of lines.

  Graph g = newGraph(numofstations); // creates new graph.

  while (input < numberoflines) // inputs the each schedule
  {
    printf("Enter the number of stops: ");
    scanf("%d", &numberofstops);
    for (i = 0; i < numberofstops; i++)
    {
      scanf("%d", &timevar);
      scanf("%s", findme); // findme is passed to to function fndstnname to get the index of that functon.
      si = fndstnname(stnhead, findme, numofstations);
      ListHead = insertLL(ListHead, si, timevar, input); // inserts into priliminary linked list.
    }
    input++;
    updateGraph(g, ListHead, numberofstops); // function that creates the graph using inputted stations.
    TempHead = ListHead;
    freeLL(TempHead); // freeing the list to input new set of stations.
    ListHead = NULL;
  }

  printf("From: ");
  scanf("%s", fromstation);
  while ((strcmp(fromstation, "done") != 0))
  {
    printf("To: ");
    scanf("%s", tostation);
    printf("Arrive by: ");
    scanf("%d", &inputarriveby);
    mapFromStn = fndstnname(stnhead, fromstation, numofstations); // finds the from station index.
    mapToStn = fndstnname(stnhead, tostation, numofstations);     // finds the to station index.
    if (!canIArrive(g, mapToStn, inputarriveby))                  // checks the specific stations if there are any incoming trains at this point. This helps in certain cases.
      printf("No connection found.\n");
    else
    {
      dijkstraSSSP(g, mapToStn, mapFromStn, inputarriveby, stnheadforfn); // source is destination and destination is source;
    }
    printf("From: ");
    scanf("%s", fromstation);
  }
  printf("Thank you for using myTrain.\n");

  for (int k = 0; k < numofstations; k++)
  {
    free(stnhead[k]); // freeing all the station name 
  }
  free(stnhead); // freeing station name pointers
  freeGraph(g); // call to free the graph. 
  return 0;
}
